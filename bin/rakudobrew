#!/usr/bin/env perl
use strict;
use warnings;
use 5.010;
use Cwd qw(cwd realpath);
use FindBin qw($Bin);
use File::Path qw(remove_tree);
use File::Basename;
use File::Spec::Functions qw(catfile catdir splitdir splitpath catpath updir);
use Carp qw(croak);

my $brew_name = 'rakudobrew';
my $env_var = 'PL6ENV_VERSION';
my $local_filename = '.perl6-version';

my $prefix = catdir($Bin, updir());
my $git_reference = catfile($prefix, 'git_reference');

unless (-d $git_reference) {
    mkdir $git_reference;
}

my $GIT       = $ENV{GIT_BINARY} // 'git';
my $GIT_PROTO = $ENV{GIT_PROTOCOL} // 'git';
my $PERL5     = $^X;

my %git_repos = (
    rakudo => "$GIT_PROTO://github.com/rakudo/rakudo.git",
    MoarVM => "$GIT_PROTO://github.com/MoarVM/MoarVM.git",
    nqp    => "$GIT_PROTO://github.com/perl6/nqp.git",
    panda  => "$GIT_PROTO://github.com/tadzik/panda.git",
);

my %impls = (
    jvm => {
        name      => "jvm",
        weight    => 20,
        configure => "$PERL5 Configure.pl --backends=jvm --gen-nqp --git-reference=$git_reference --make-install",
        need_repo => ['rakudo', 'nqp'],
    },
    moar => {
        name      => "moar",
        weight    => 30,
        configure => "$PERL5 Configure.pl --backends=moar --gen-moar --git-reference=$git_reference --make-install",
        need_repo => ['rakudo', 'nqp', 'MoarVM'],
    },
    'pre-glr' => {
        name      => "pre-glr",
        weight    => 30,
        configure => "git checkout pre-glr; git pull; $PERL5 Configure.pl --backends=moar --gen-moar --git-reference=$git_reference --make-install",
        need_repo => ['rakudo', 'nqp', 'MoarVM'],
    },
);

sub run {
    system(@_) and croak "Failed running ".$_[0]
}

{ # Check whether we are called as a shim and forward if yes.
    my (undef, undef, $prog_name) = splitpath($0);

    # TODO: Mac is also case insensitive. Is this way to compensate for insensitivity safe?
    if ($prog_name ne $brew_name &&
    ($^O !~ /win32/i || $prog_name =~ /^\Q$brew_name\E\z/i)) {
        do_exec($prog_name, \@ARGV);
    }
}

my $arg = shift // 'help';
if ($arg eq 'switch') {
    my $version = shift;
    set_global_version($version);
} elsif ($arg eq 'nuke') {
    my $version = shift;
    nuke($version);
} elsif ($arg eq 'rehash') {
    rehash();
} elsif ($arg eq 'list' or $arg eq 'versions') {
    my $cur = get_version() // '';
    map { say $cur eq $_ ? "* $_" : "  $_" } sort { $a cmp $b } list();
} elsif ($arg eq 'list-available') {
    my ($cur_backend, $cur_rakudo) = split '-', (get_version() // ''), 2;
    $cur_backend |= '';
    $cur_rakudo |= '';
    say "Available backends:";
    map { say $cur_backend eq $_ ? "* $_" : "  $_" } available_backends();
    say "";
    say "Available Rakudo versions:";
    map { say $cur_rakudo eq $_ ? "* $_" : "  $_" } available_rakudos();
} elsif ($arg eq 'current') {
    if (my $c = get_version()) {
        say "Currently running $c"
    } else {
        say "Not running anything at the moment. Use '$brew_name switch' to set a version";
    }
} elsif ($arg eq 'build') {
    my $impl = shift;
    my $ver = shift
        if @ARGV && $ARGV[0] !~ /^--/;
    my $configure_opts = '';
    if (@ARGV && $ARGV[0] =~ /^--configure-opts=/) {
        $configure_opts = shift;
        $configure_opts =~ s/^\-\-configure-opts=//;
        $configure_opts =~ s/^'//;
        $configure_opts =~ s/'$//;
    }
    if ($impl && $impl eq 'all') {
        for (available_backends()) {
            build_impl($_, $ver, $configure_opts);
        }
    } else {
        build_impl($impl, $ver, $configure_opts);
    }
} elsif ($arg eq 'triple') {
    my ($rakudo_ver, $nqp_ver, $moar_ver) = (shift, shift, shift);
    build_triple($rakudo_ver, $nqp_ver, $moar_ver);
} elsif ($arg eq 'build-panda') {
    my $panda_ver = shift;
    build_panda($panda_ver);
    rehash();
} elsif ($arg eq 'self-upgrade') {
    self_upgrade();
} elsif ($arg eq 'test') {
    my $version = shift;
    if ($version && $version eq 'all') {
        for (list()) {
            test($_);
        }
    } else {
        test($version);
    }
# plenv interface
} elsif ($arg eq 'exec') {
    my $prog_name = shift;
    do_exec($prog_name, \@ARGV);
} elsif ($arg eq 'version') {
    if (my $version = get_version()) {
        say $version;
    }
    else {
        say STDERR "$brew_name: No version set.";
        exit 1;
    }
} elsif ($arg eq 'init') {
    init(@ARGV);
} elsif ($arg eq 'sh') {
    if (!@ARGV) {
        my $shell_version = get_shell_version();
        if (defined $shell_version) {
            print "echo \"$shell_version\"";
        }
        else {
            print "echo \"$brew_name: no shell-specific version configured\"";
        }
    }
    else {
        my $command = shift;
        if ($command eq '--unset') {
            print get_shell_unsetter_code();
        }
        else {
            print get_shell_setter_code($command);
        }
    }
} elsif ($arg eq 'shell') {
    if ($^O =~ /win32/i) {
        say <<EOT;
To (un)set a version locally in this running shell session use the following commands:
CMD:
SET PL6_VERSION=YOUR_VERSION
SET PL6_VERSION=                # Unset. No trailing whitespace!

PowerShell:
\$Env:PL6_VERSION="YOUR_VERSION"
Remove-Item Env:\\PL6_VERSION    # Unset.
EOT
    }
    else {
        say "The shell hook required to use the 'shell' subcommands is not installed.";
        say "Run '$brew_name init' for installation instructions.";
    }
} elsif ($arg eq 'local') {
    if (!@ARGV) {
        my $version = get_local_version();
        if ($version) {
            say $version;
        }
        else {
            say "$brew_name: no local version configured for this directory";
        }
    }
    else {
        set_local_version($ARGV[0]);
    }
} elsif ($arg eq 'global') {
    if (!@ARGV) {
        my $version = get_global_version();
        if ($version) {
            say $version;
        }
        else {
            say "$brew_name: no global version configured";
        }
    }
    else {
        set_global_version($ARGV[0]);
    }
} elsif ($arg eq 'which') {
    if (!@ARGV) {
        say STDERR "Usage: $brew_name which <command>";
    }
    else {
        map {say $_} which(@ARGV);
    }
} elsif ($arg eq 'whence') {
    if (!@ARGV) {
        say STDERR "Usage: $brew_name whence [--path] <command>";
    }
    else {
        map {say $_} whence(@ARGV);
    }
} else {
    say "Usage:";
    say "$brew_name current";
    say "$brew_name list-available";
    say "$brew_name build " , (join "|", available_backends(), "all"), " [tag|branch|sha-1]", " [--configure-opts=]";
    say "$brew_name build-panda [panda-ver]";
    say "$brew_name triple [rakudo-ver [nqp-ver [moar-ver]]]";
    say "$brew_name rehash";
    say "$brew_name switch ", (join "|", available_backends());
    say "$brew_name nuke ", (join "|", available_backends());
    say "$brew_name self-upgrade";
    say "$brew_name test [", (join "|", available_backends(), "all"), "]";
    say "$brew_name exec <command> [command-args]";
    say "$brew_name init";
    say "$brew_name shell [--unset|version]";
    say "$brew_name local [version]";
    say "$brew_name global [version]";
    say "$brew_name version";
    say "$brew_name versions # or $brew_name list";
    say "$brew_name which <command>";
    say "$brew_name whence [--path] <command>";
}

exit;

sub available_rakudos {
    my @output = qx|$GIT ls-remote --tags $git_repos{rakudo}|;
    my @tags = grep( m{refs/tags/([^\^]+)\^\{\}}, @output );
    return map(m{tags/([^\^]+)\^}, @tags );
}

sub list {
    opendir(my $dh, $prefix);
    grep {/^[^.]/ && -d catdir($prefix, $_)
          && $_ ne 'bin' && $_ ne 'git_reference' && $_ ne 'panda'} readdir($dh);
}

sub nuke {
    my $version = shift;
    match_and_run($version, sub {
        my $matched = shift;
        say "Nuking $matched";
        remove_tree(catdir($prefix, $matched));
    });
    # Might have lost executables -> rehash.
    rehash();
}

sub match_and_run {
    my ($version, $action) = @_;
    if (!$version) {
        say "Switch to what?";
        say "Available builds";
        map {say} list();
        return;
    }
    opendir(my $dh, $prefix);
    my @match = grep { /\Q$version/ } list();
    my ($matched, $ambiguous) = @match;
    if ($ambiguous) {
        my ($exact) = grep { $_ eq $version } @match;
        if ($exact) {
            ($matched, $ambiguous) = $exact;
        }
    }
    if ($matched and not $ambiguous) {
        $action->($matched);
    } elsif (@match) {
        say "Sorry, I'm not sure if you mean:";
        say $_ for @match;
    } else {
        say "Sorry, I have no idea what '$version' is";
    }
}

sub available_backends {
    map {$_->{name}} sort {$a->{weight} <=> $b->{weight}} values %impls;
}

sub build_impl {
    my ($impl, $ver, $configure_opts) = @_;
    unless (defined $impl) {
        say "Build what?";
        my ($cur) = split '-', (get_version() // ''), 2;
        $cur //= '';
        map { say $cur eq $_ ? "* $_" : "  $_" } available_backends();
        return;
    }
    if ($impl eq "panda") {
        build_panda();
        return;
    }
    unless (exists $impls{$impl}) {
        say "Building Rakudo with backend '$impl' is NYI. Well volunteered!";
        return;
    }
    $ver //= 'nom';
    chdir $prefix;
    unless (-d "$impl-$ver") {
        for(@{$impls{$impl}{need_repo}}) {
            update_git_reference($_);
        }
        run "$GIT clone --reference $git_reference/rakudo $git_repos{rakudo} $impl-$ver";
    }
    chdir "$impl-$ver";
    run "$GIT fetch";
    # of people say 'build somebranch', they usually mean 'build origin/somebranch'
    my $ver_to_checkout = $ver;
    eval {
        run "$GIT rev-parse -q --verify origin/$ver";
        $ver_to_checkout = "origin/$ver";
    };
    run "$GIT checkout $ver_to_checkout";

    run $impls{$impl}{configure} . " $configure_opts";

    if (-d 'panda') {
        say "Updating panda as well";
        build_panda(undef, "$impl-$ver");
    }
    # Might have new executables now -> rehash.
    rehash();
    unless (get_version()) {
        set_global_version("$impl-$ver");
    }
    say "Done, $impl-$ver built";
}

sub update_git_reference {
    my $repo = shift;
    my $back = cwd();
    print "Update git reference: $repo\n";
    chdir $git_reference;
    unless (-d $repo) {
        run "$GIT clone $git_repos{$repo} $repo";
    }
    chdir $repo;
    run "$GIT pull";
    chdir $back;
}

sub make {
    my $command = shift;
	if(!-f 'Makefile') {
	    say STDERR "No Makefile found. Aborting.";
		exit 1;
    }
	my $makefile = slurp('Makefile');
	if($makefile =~ /^MAKE\s*=\s*(\w+)\s*$/m) {
        my $make = $1;
        run("$make $command");
	}
	else {
        say STDERR "Couldn't determine correct make program. Aborting.";
		exit 1;
    }
}

sub build_triple {
    my ($rakudo_ver, $nqp_ver, $moar_ver) = @_;
    my $impl = "moar";
    $rakudo_ver //= 'HEAD';
    $nqp_ver //= 'HEAD';
    $moar_ver //= 'HEAD';
    chdir $prefix;
    my $name = "$impl-$rakudo_ver-$nqp_ver-$moar_ver";
    unless (-d $name) {
        update_git_reference('rakudo');
        run "$GIT clone --reference $git_reference/rakudo $git_repos{rakudo} $name";
    }
    chdir $name;
    run "$GIT pull";
    run "$GIT checkout $rakudo_ver";
    if (-e 'Makefile') {
        make('realclean');
    }

    unless (-d "nqp") {
        update_git_reference('nqp');
        run "$GIT clone --reference $git_reference/nqp $git_repos{nqp}";
    }
    chdir "nqp";
    run "$GIT pull";
    run "$GIT checkout $nqp_ver";

    unless (-d "MoarVM") {
        update_git_reference('MoarVM');
        run "$GIT clone --reference $git_reference/MoarVM $git_repos{MoarVM}";
    }
    chdir "MoarVM";
    run "$GIT pull";
    run "$GIT checkout $moar_ver";
    run "$PERL5 Configure.pl --prefix=" . catdir(updir(), updir(), 'install');
    make('install');

    chdir updir();
    run "$PERL5 Configure.pl --backend=moar --prefix=" . catdir(updir(), 'install');
    make('install');

    chdir updir();
    run "$PERL5 Configure.pl --backend=moar";
    make('install');

    if (-d 'panda') {
        say "Updating panda as well";
        build_panda(undef, $name);
    }
    # Might have new executables now -> rehash.
    rehash();
    unless (get_version()) {
        set_global_version($name);
    }
    say "Done, $name built";
}

sub build_panda {
    my ($panda_ver, $version) = @_;
    $panda_ver //= 'HEAD';
    $version //= get_version();
    if (!$version) {
        say STDERR "$brew_name: No version set.";
        exit 1;
    }
    chdir catdir($prefix, $version);
    unless (-d 'panda') {
        run "$GIT clone $git_repos{panda}";
    }
    chdir 'panda';
    run "$GIT pull -q";
    run "$GIT checkout -q $panda_ver";
    run which('perl6', $version) . " rebootstrap.pl";
    # Might have new executables now -> rehash.
    rehash();
    say "Done, built panda for $version";
}

sub slurp {
    my $file = shift;
    open(my $fh, '<', $file);
    local $/ = '';
    my $ret = <$fh>;
    close($fh);
    return $ret;
}

sub spurt {
    my ($file, $cont) = @_;
    open(my $fh, '>', $file);
    say $fh $cont;
    close($fh);
}

sub trim {
    my $text = shift;
    $text =~ s/^\s+|\s+$//g;
    return $text;
}

sub rehash {
    sub dir {
        my $name = shift;
        opendir(my $dh, $name) or return;
        my @ret;
        while (my $entry = readdir $dh) {
            next if $entry =~ /^\./;
            next if !-f catfile($name, $entry);
            push @ret, $entry
        }
        closedir $dh;
        return @ret;
    }

    my @paths = ();
    for my $version (list()) {
        push @paths, get_bin_paths($version);
    }

    say "Updating shims";

    { # Remove the existing shims.
        opendir(my $dh, catdir($prefix, 'bin'));
        while (my $entry = readdir $dh) {
            next if $entry =~ /^\./;
            next if $entry =~ /$brew_name/;
            next if $entry =~ /$brew_name\.cmd/;
            unlink catfile($prefix, 'bin', $entry);
        }
        closedir $dh;
    }

    my @bins = map { dir($_) } @paths;

    for (@bins) {
		if ($^O =~ /win32/i) {
			spurt(catfile($prefix, 'bin', $_), '"perl" '.catfile($prefix, 'bin', $brew_name)." exec $_ \%*");
		}
		else {
			link $0, catfile($prefix, 'bin', $_);
		}
    }
}

sub self_upgrade {
    chdir $prefix;
    run "$GIT pull";
}

sub test {
    my $version = shift || get_version();
    if (!$version) {
        say STDERR "$brew_name: No version set.";
        exit 1;
    }
    my @match = grep { /\Q$version/ } list();
    my ($matched, $ambiguous) = @match;
    if ($ambiguous) {
        my ($exact) = grep { $_ eq $version } @match;
        if ($exact) {
            ($matched, $ambiguous) = $exact;
        }
    }
    if ($matched and not $ambiguous) {
        say "Spectesting $matched";
        chdir catdir($prefix, $matched);
        make('spectest');
    } elsif (@match) {
        say "Sorry, I'm not sure if you mean:";
        say $_ for @match;
    } else {
        say "Sorry, I have no idea what '$version' is";
        say "Have you run '$brew_name build $version' yet?";
    }
}

sub not_found {
    my $version = shift;
    return "$brew_name: version '$version' not installed.";
}

sub check_version {
    my $version = shift;
    return undef if !defined $version;
    my %versionsMap = map { $_ => 1 } list();
    return exists($versionsMap{$version});
}

sub get_bin_paths {
    my $version = shift;
    my $program = scalar(shift) || undef;
    return (
        catfile($prefix, $version, 'install', 'bin', $program // ()),
        catfile($prefix, $version, 'install', 'share', 'perl6', 'site', 'bin', $program // ()),
    );
}

sub init {
    my $brew_exec = catfile($Bin, $brew_name);
    if ($^O =~ /win32/i) {
        say <<EOT;
# CMD:
# To install $brew_name permanently type the following into your terminal:
#   SETX PATH "%PATH%;$Bin"
# To make use of $brew_name in this session only use
#   SET PATH "%PATH%;$Bin"
#
# PowerShell:
# To install $brew_name permanently type the following into your terminal
# (only works with an administrative console window):
#   [Environment]::SetEnvironmentVariable("PATH", "\$Env:PATH;$Bin", "User")
# To make use of $brew_name in this session only use
#   \$Env:PATH = "\$Env:PATH;$Bin"
#
# Using the GUI:
# Start -> right click on "Computer" -> Properties -> (Advanced system settings)
# -> Advanced -> Environment Variables... ->  System variables
# -> select PATH -> Edit... -> append ";$Bin"
EOT
    }
    else {
        if (@_ and $_[0] eq '-') {
            say <<EOT;
export PATH="$Bin:\${PATH}"
$brew_name() {
  local command
  command="\$1"
  if [ "\$#" -gt 0 ]; then
    shift
  fi

  case "\$command" in
  shell)
    eval "`$brew_name "sh" "\$@"`";;
  *)
    command $brew_name "\$command" "\$@";;
  esac
}
EOT
        }
        else {
        say <<EOT;
# Load $brew_name automatically by adding
#   eval "\$($brew_exec init -)"
# to your local profile file.
# (often ~/.bash_profile or ~/.profile)
# This can be easily done using:

echo 'eval "\$($brew_exec init -)"' >> ~/.profile

EOT
        }
    }
}

sub get_shell_setter_code {
    my $version = shift;

    if ($^O =~ /win32/i) {
        #NYI on windows.
        die;
    }
    else {
        if (check_version($version)) {
            return "export $env_var=\"$version\"";
        }
        else {
            return 'echo "'.not_found($version).'";return 1';
        }
    }
}

sub get_shell_unsetter_code {
    if ($^O =~ /win32/i) {
        #NYI on Windows.
        die;
    }
    else {
        return "unset $env_var";
    }
}

sub get_shell_version {
    # Check for shell version by looking for $PL6ENV_VERSION the environment.
    if (defined $ENV{$env_var}) {
        my $version = $ENV{$env_var};
        if (check_version($version)) {
            return $version;
        }
        else {
            say STDERR "Version '$version' is set via the PL6ENV_VERSION environment variable.";
            say STDERR "This version is not installed. Ignoring.";
            say STDERR '';
            return undef;
        }
    }
    else {
        return undef;
    }
}

sub get_local_version {
    my ($vol, $path, undef) = splitpath(realpath(), 1);
    my @fragments = splitdir($path);
    while (@fragments) {
        my $filepath = catpath($vol, catdir(@fragments), $local_filename);
        if (-f $filepath) {
            my $version = trim(slurp($filepath));
            if(check_version($version)) {
                return $version;
            }
            else {
                say STDERR "Version '$version' is given in the";
                say STDERR "$filepath";
                say STDERR "file. This version is not installed. Ignoring.";
                say STDERR '';
            }
        }
        pop @fragments;
    }
    return undef;
}

sub set_local_version {
    my $version = shift;
    if (check_version($version)) {
        spurt($local_filename, $version);
    }
    else {
        say STDERR not_found($version);
    }
}


sub get_global_version {
    if (-e catdir($prefix, 'CURRENT')) {
        my $cur = slurp(catdir($prefix, 'CURRENT'));
        chomp $cur;
        return $cur;
    }
    else {
        return undef;
    }
}

sub set_global_version {
    my $version = shift;
    match_and_run($version, sub {
        my $matched = shift;
        say "Switching to $matched";
        spurt(catfile($prefix, 'CURRENT'), $matched);
    });
}

sub get_version {
    my $version = get_shell_version();
    return $version if defined $version;
    
    # Check for local version by looking for a `.perl6-version` file in the current and parent folders.
    $version = get_local_version();
    return $version if defined $version;

    # Check for global version by looking at `$prefix/CURRENT` (`$prefix/version`)
    return get_global_version();
}

sub whence {
    my $param = shift;
    my $pathmode = $param eq '--path';
    my $prog = $pathmode ? shift : $param;

    my @matches = ();
    for my $version (list()) {
        for my $path (get_bin_paths($version, $prog)) {
            if (-f $path) {
                if ($pathmode) {
                    push @matches, $path;
                }
                else {
                    push @matches, $version;
                }
                last;
            }
        }
    }
    return @matches;
}

sub which {
    my $prog = shift;
    my $version = shift // get_version();
    if (!$version) {
        say STDERR "$brew_name: No version set.";
        exit 1;
    }

    my $target; {
        my @paths = get_bin_paths($version, $prog);
        if ($^O =~ /win32/i) {
            # On Windows we have to add a .pl suffix (if not already there) to program filenames
            # to make them work without having to call perl explicitly. Thus we strip that prefix
            # when searching for the target.
            my $prog_no_suffix = $prog;
            if ($prog_no_suffix =~ s/\.pl$//) {
                push @paths, get_bin_paths($version, $prog_no_suffix);
            }
        }
        for my $path (@paths) {
            if (-e $path) {
                $target = $path;
                last;
            }
        }
    }

    if (!$target) {
        say STDERR "$brew_name: $prog: command not found";
        if(whence($prog)) {
            say STDERR <<EOT;

The '$prog' command exists in these Perl 6 versions:
EOT
            map {say STDERR $_} whence($prog);
        }
        exit 1;
    }

    return $target;
}

sub do_exec {
    my ($program, $args) = @_;

    my $target = which($program);
    
    # Run.
    exec { $target } ($target, @$args);
    die "Executing $target failed with: $!";
}
