#!/usr/bin/env perl
use strict;
use warnings;
use 5.010;
use FindBin qw($Bin);

my $arg = shift // 'help';
my $prefix = "$Bin/..";

my $GIT = $ENV{GIT_BINARY} // 'git';

my %impls = (
    parrot => {
        name      => "parrot",
        weight    => 10,
        configure => 'perl Configure.pl --backends=parrot --gen-parrot --gen-nqp',
    },
    jvm => {
        name      => "jvm",
        weight    => 20,
        configure => 'perl Configure.pl --backends=jvm --gen-nqp=master',
    },
    moar => {
        name      => "moar",
        weight    => 30,
        configure => 'perl Configure.pl --backends=moar --gen-moar',
    },
);

sub run {
    system(@_) and die "Failed running ".$_[0]
}

if ($arg eq 'switch') {
    my $impl = shift;
    switch($impl);
} elsif ($arg eq 'rehash') {
    rehash();
} elsif ($arg eq 'list') {
    my $cur = current() || '';
    map { say $cur eq $_ ? "* $_" : "  $_" } list();
} elsif ($arg eq 'current') {
    if (my $c = current()) {
        say "Currently running $c"
    } else {
        say "Not running anything at the moment. Use 'rakudobrew switch' to set an implementation";
    }
} elsif ($arg eq 'available') {
    available();
} elsif ($arg eq 'build') {
    my ($impl, $ver) = (shift, shift);
    if ($impl && $impl eq 'all') {
        for (available_backends()) {
            build_impl($_, $ver);
        }
    } else {
        build_impl($impl, $ver);
    }
} elsif ($arg eq 'triple') {
    my ($rakudo_ver, $nqp_ver, $moar_ver) = (shift, shift, shift);
    build_triple($rakudo_ver, $nqp_ver, $moar_ver);
} elsif ($arg eq 'build-panda') {
    build_panda();
    rehash();
} else {
    say "Usage:";
    say "rakudobrew current";
    say "rakudobrew list";
    say "rakudobrew available";
    say "rakudobrew build " , (join "|", available_backends(), "all"), " [tag|branch|sha-1]";
    say "rakudobrew build-panda";
    say "rakudobrew rehash";
    say "rakudobrew switch ", (join "|", available_backends());
}

sub current {
    if (-e "$prefix/CURRENT") {
        my $cur = slurp("$prefix/CURRENT");
        chomp $cur;
        return $cur;
    }
}

sub list {
    opendir(my $dh, $prefix);
    grep {/^[^.]/ && -d "$prefix/$_" && $_ ne 'bin'} readdir($dh);
}

sub switch {
    my $impl = shift;
    if (!$impl) {
        say "Switch to what?";
        say "Available builds";
        map {say} list();
        return;
    }
    opendir(my $dh, $prefix);
    my @match = grep { /$impl/ } list();
    my ($matched, $ambiguous) = @match;
    if ($matched and not $ambiguous) {
        say "Switching to $matched";
        spurt("$prefix/CURRENT", $matched);
        rehash();
    } elsif (@match) {
        say "Sorry, I'm not sure if you mean:";
        say $_ for @match;
    } else {
        say "Sorry, I have no idea what '$impl' is";
    }
}

sub available {
    say "Available backends:";
    say for available_backends();
    say "";
    say "Available Rakudo versions (top-15):";
    say for (sort {$b cmp $a} grep /^20[0-9][0-9]/, available_rakudos())[0..14];
}

sub available_backends {
    map {$_->{name}} sort {$a->{weight} <=> $b->{weight}} values %impls;
}

# TODO Vulnerable to https://developer.github.com/v3/#rate-limiting due to
# unauthenticated API calls. Cache locally till X-RateLimit-Reset, maybe?
sub available_rakudos {
    eval {
        require LWP::UserAgent;
        require LWP::Protocol::https;
        1;
    } or do {
        say "cannot retrieve Rakudo versions because:",
            " LWP::UserAgent or LWP::Protocol::https didn't load (not installed?)";
        return;
    };

    my $ua = LWP::UserAgent->new;
    $ua->env_proxy;
    $ua->timeout(10);
    $ua->agent($ua->agent . " rakudobrew (https://github.com/tadzik/rakudobrew)");
    $ua->default_header("Accept" => "application/vnd.github.v3+json");

    my @tags;

    my $tries = 10; # dumb way to avoid accidental infinite loop
    my $tags_uri = "https://api.github.com/repos/rakudo/rakudo/tags?per_page=100";
    while ($tags_uri && $tries) {
        $tries--;
        my $res = $ua->get($tags_uri);
        unless ($res->is_success) {
            say "cannot retrieve Rakudo versions because: ", $res->status_line;
            return;
        }
        ($tags_uri) = $res->header("Link") =~ /<(.+?)>;\s*rel="next"/;
        push @tags, $res->decoded_content =~ /"name":\s*"(.+?)"/g; # YOLO
    }

    return @tags;
}

sub build_impl {
    my ($impl, $ver) = @_;
    unless (defined $impl) {
        say "Build what?";
        available();
        return;
    }
    if ($impl eq "panda") {
        build_panda();
        return;
    }
    unless (exists $impls{$impl}) {
        say "Building $impl is NYI. Well volunteered!";
        return;
    }
    $ver //= 'HEAD';
    chdir $prefix;
    unless (-d "$impl-$ver") {
        run "$GIT clone git://github.com/rakudo/rakudo.git $impl-$ver";
    }
    chdir "$impl-$ver";
    run "$GIT pull";
    run "$GIT checkout $ver";
    if (-e 'Makefile') {
        run 'make realclean';
    }
    run $impls{$impl}{configure};
    if (system 'make install') {
        if ($^O eq "darwin") {
            run 'make install'; # try again because OS X make is stupid
        } else {
            die "Failed running make install";
        }
    }
    if (-d 'panda') {
        say "Updating panda as well";
        my $oldcur = current();
        switch("$impl-$ver");
        build_panda();
        switch($oldcur);
    }
    unless (current()) {
        switch("$impl-$ver");
    }
    say "Done, $impl-$ver built";
}

sub build_triple {
    my ($rakudo_ver, $nqp_ver, $moar_ver) = @_;
    my $impl = "moar";
    $rakudo_ver //= 'HEAD';
    chdir $prefix;
    my $name = "$impl-$rakudo_ver-$nqp_ver-$moar_ver";
    unless (-d $name) {
        run "$GIT clone git://github.com/rakudo/rakudo.git $name";
    }
    chdir $name;
    run "$GIT pull";
    run "$GIT checkout $rakudo_ver";
    if (-e 'Makefile') {
        run 'make realclean';
    }
    
    unless (-d "nqp") {
        run "$GIT clone git://github.com/perl6/nqp.git";
    }
    chdir "nqp";
    run "$GIT pull";
    run "$GIT checkout $nqp_ver";

    unless (-d "MoarVM") {
        run "$GIT clone git://github.com/MoarVM/MoarVM.git";
    }
    chdir "MoarVM";
    run "$GIT pull";
    run "$GIT checkout $moar_ver";
    run "perl Configure.pl --prefix=../../install";
    run "make install";
    
    chdir "..";
    run "perl Configure.pl --backend=moar --prefix=../install";
    run "make install";
    
    chdir "..";
    run "perl Configure.pl --backend=moar";
    
    if (system 'make install') {
        if ($^O eq "darwin") {
            run 'make install'; # try again because OS X make is stupid
        } else {
            die "Failed running make install";
        }
    }
    if (-d 'panda') {
        say "Updating panda as well";
        my $oldcur = current();
        switch($name);
        build_panda();
        switch($oldcur);
    }
    unless (current()) {
        switch($name);
    }
    say "Done, $name built";
}

sub build_panda {
    my $impl = current();
    chdir "$prefix/$impl";
    unless (-d 'panda') {
        run "$GIT clone git://github.com/tadzik/panda.git";
    }
    chdir 'panda';
    run "$GIT pull";
    run "perl6 rebootstrap.pl";
    say "Done, built panda for $impl";
}

sub slurp {
    my $file = shift;
    open(my $fh, '<', $file);
    local $/ = '';
    my $ret = <$fh>;
    close($fh);
    return $ret;
}

sub spurt {
    my ($file, $cont) = @_;
    open(my $fh, '>', $file);
    say $fh $cont;
    close($fh);
}

sub rehash {
    sub dir {
        my $name = shift;
        opendir(my $dh, $name) or return;
        my @ret;
        while (my $entry = readdir $dh) {
            next if $entry =~ /^\./;
            push @ret, "$name/$entry"
        }
        closedir $dh;
        return @ret;
    }

    sub spurt_shim {
        my ($source, $destdir) = @_;
        my $tmpl = '#!/bin/sh
    %s "$@"
    ';
        my $contents = sprintf $tmpl, $source;
        my ($filename) = $source =~ m{/([^/]+)$};
        spurt("$destdir/$filename", $contents);
        chmod 0755, "$destdir/$filename";
    }

    my $current = current() or return;
    my ($type) = split '-', $current;

    my @paths = "$prefix/$current/install/bin";
    if ($type eq 'parrot') {
        my $parverdir = `$prefix/$current/install/bin/parrot_config versiondir`;
        chomp $parverdir;
        push @paths, "$prefix/$current/install/lib/$parverdir/languages/perl6/site/bin";
    } elsif ($type eq 'jvm') {
        push @paths, "$prefix/$current/install/languages/perl6/site/bin";
    } elsif ($type eq 'moar') {
        push @paths, "$prefix/$current/install/languages/perl6/site/bin";
    } elsif ($type eq 'moar_jit') {
        push @paths, "$prefix/$current/install/languages/perl6/site/bin";
    }

    say "Updating shims";
    my @bins = map { dir($_) } @paths;
    # TODO: Remove those that were there before?
    for (@bins) {
        spurt_shim $_, "$prefix/bin";
    }
}
